---
title: '从零开始编译器-2'
layout: post
subtitle: ''
tags:
  - SimpleLang, compiler
---

# 语法分析

## 什么是语法分析

语法分析把词法分析的结果组装成一颗语法树，我也简单介绍下，同样如果你懂编译原理的画可以跳过这一段。

比方说上面词法分析提到的代码：

```c
int a = 1234 + b;
```

经过词法分析以后，会转换为符号串（见词法表1），而语法分析就是分析这串符号串是否符合语法。

上面这段变量定义的语法我们这么定义

```
类型 变量 [= 表达式] ;
```

*中括号表示可选*

**类型**允许是**类型保留字**，或者**单词**（针对自定义类型）

**变量**允许是**单词**

**表达式**允许是**数字**、**单词**、或者通过符号连接的**表达式**

注意这里规则有个比较特别的地方，表达式的定义里出现了自己，这是因为语法定义中，表达式必须在特定的地方出现，所以语法分析器是可以通过上下文分析出递归的符号的，因此我们可以在语法规则里用递归。

## 语法分析工具: bison

我用的语法分析工具是 bison, 它一般和 flex 一起使用，同样是把你定义的语法文件翻译为 c 文件，你可以把它生成的文件加入你的编译器工程，你就完成了语法分析工作。

语法规则我们一般使用[巴科斯范式](https://baike.baidu.com/item/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F/1849549?fromtitle=BNF&fromid=7328753&fr=aladdin)来表示，而我使用的语法分析工具 bison 用接近巴科斯范式的语法来定义语法，比如上面这个 c 语言变量定义的语法定义大致是这样：

```
def
    : type IDENTIFIER			{ $$=makeType($2); }
    | type IDENTIFIER = expr	{ $$=makeType($2, $4); }
    ;
type
    : TYPEKEY		
    | IDENTIFIER
    ;
expr 
	: NUMBER
	| expr TOKEN expr			{ ... }
	;
...
    
```

大括号里

*（未完待续)*

